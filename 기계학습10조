from google.colab import drive
drive.mount('/content/drive')

from Bio import SwissProt
import gzip
import numpy as np
###Other imports could be added if necessary###


#########        PARSING & GETTING SEQUENCE & ENZYME CLASSIFICATION         #############

###Use parsing function that is available in biopython###
handle = SwissProt.parse(gzip.open("/content/drive/My Drive/Colab Notebooks/uniprot_sprot.dat.gz", "rt"))

###Create a list for the sequence information for each protein###
seq_list = []

###Create a list indicating whether the given protein is an enzyme or not###
ans_list = []

###For each protein in the parsed data file, add the sequence and enzyme information into the lists made###
for record in handle:
  a = record.description
  b = record.sequence
  seq_list.append(b)
  if a.count("EC") > 0:
    ans_list.append(1)
  else:
    ans_list.append(0)

###Save the sequence and enzyme data into a dictionary as in for HW (week9~11)###
seq_ans_dict = {'sequence': seq_list, 'answers': ans_list}

###Counts the number of enzymes in the whole set of proteins###
#enzyme_count = 0
#for enzymes in seq_ans_dict['answers']:
#  if enzymes == 1:
#    enzyme_count = enzyme_count + 1
#print(enzyme_count)

###################################################################################################




###################################     FEATURIZATION      ########################################

###Organized amino acids that correspond to certain attributes that can be used to create the features for a given protein###
charge_dict = {'Neutral': 'ACFGHILMNPQSTVWY', 'Negative': 'DE', 'Positive': 'KR'} ##Charge
hydroph_dict = {'Hydrophobic': 'CFILMVW', 'Neutral': 'AGHPSTY', 'Polar': 'DEKNQR'} ##Hydrophobicity
normVDW_dict = {'Small': 'ACDGPST', 'Medium': 'EILNQV', 'Large': 'FHKMRWY'}
polar_dict = {'Low': 'CFILMVWY', 'Medium': 'AGPST', 'High': 'DEHKNQR'} ##Polarity
polariz_dict = {'Low': 'ADGST', 'Medium': 'CEILNPQV', 'High': 'FHKMRWY'} ##Polarizability
ss_dict = {'Coil': 'DGNPS', 'Helix': 'AEHKLMQR', 'Strand': 'CFITVWY'} ##Secondary structure
sol_dict = {'Buried': 'ACFGILVW', 'Intermediate': 'HMPSTY', 'Exposed': 'DEKNRQ'} ##Solvent Accessibility

Attribute = (charge_dict, hydroph_dict, normVDW_dict, polar_dict, polariz_dict, ss_dict, sol_dict)
Attribute_dict = {'Charge': charge_dict, 
                  'Hydrophobicity': hydroph_dict, 
                  'Normalized_vdW_volume': normVDW_dict, 
                  'Polarity': polar_dict, 
                  'Polarizability': polariz_dict, 
                  'Secondary Structure': ss_dict, 
                  'Solvent Accessibility': sol_dict}

###Use number codes as described in [https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6139332]###
def AASeqToNum(prot_seq, Attribute):
  new_seq = prot_seq
  index = 1
  for k, v in Attribute.items():
    for AA in v:
      new_seq = new_seq.replace(AA, str(index))
    index = index + 1
  num_seq = new_seq
  return num_seq

########## CALCULATING COMPOSITION ##############
def CalcComp(prot_seq, Attribute, Attribute_name):
  seq_length = len(prot_seq)
  Comp_results = {}
  num_seq = AASeqToNum(prot_seq, Attribute)
  Comp_vals = ['1', '2', '3']
  for val in Comp_vals:
    Comp_results[Attribute_name + '_C%s'%(val)] = num_seq.count(val)/seq_length
  return Comp_results

########## CALCULATING TRANSITION ##############
def CalcTrans(prot_seq, Attribute, Attribute_name):
  seq_length = len(prot_seq)
  Trans_results = {}
  num_seq = AASeqToNum(prot_seq, Attribute)
  Trans_vals = ['12', '13', '23']
  for val in Trans_vals:
    Trans_results[Attribute_name + '_T%s'%(val)] = (num_seq.count(val) + num_seq.count(val[::-1]))/(seq_length-1)
  return Trans_results

########## CALCULATING DISTRIBUTION ##############
def CalcDist(prot_seq, Attribute, Attribute_name):
  seq_length = len(prot_seq)
  Dist_results = {}
  num_seq = AASeqToNum(prot_seq, Attribute)
  Dist_vals = ['1', '2', '3']
  Dist_perc = ['0%', '25%', '50%', '75%', '100%']
  corr_frac = [0, 0.25, 0.5, 0.75, 1]
  for val in Dist_vals:
    val_count = num_seq.count(val)
    perc_index = 0
    for frac in corr_frac:
      perc = round(val_count * frac)
      if perc == 0:
        perc = 1    
      index = -1
      count = 1
      while int(perc+1) > count:
        index = num_seq.find(val, index+1)
        count = count + 1
      Dist_results[Attribute_name + '_D%s_%s'%(val, Dist_perc[perc_index])] = (index + 1)/seq_length
      if num_seq.find(val) == 0 and perc == 1:
        Dist_results[Attribute_name + '_D%s_%s'%(val, Dist_perc[perc_index])] = 0
      perc_index = perc_index + 1
  return Dist_results

######## TEST CODE FOR GENERATING SEQUENCE USING CHARGE ATTRIBUTE #######
###Print the amino acid sequence for the first protein###
test_seq = seq_ans_dict['sequence'][0]
print(test_seq)

######## TEST CODE FOR THE TEST SEQUENCE FOR CALCULATING CTD #############
TEST = AASeqToNum(test_seq, charge_dict)
TEST1 = CalcComp(test_seq, charge_dict, 'Charge')
TEST2 = CalcTrans(test_seq, charge_dict, 'Charge')
TEST3 = CalcDist(test_seq, charge_dict, 'Charge')
print(TEST, '\n', TEST1, '\n', TEST2, '\n', TEST3)


########## On-work. Aim to create a dictionary with an array of features and list indicating classification as enzymes ###
featurized_ans_dict = {}

for i in range(2):
  test_seq = seq_ans_dict['sequence'][i]
  result_dict = {}
  for k, v in Attribute_dict.items():
    result_dict.update(CalcComp(test_seq, v, k))
    result_dict.update(CalcTrans(test_seq, v, k))
    result_dict.update(CalcDist(test_seq, v, k))
  #print(result_dict)
  Feature_list = list(result_dict.values())

### Expected output should have a dictionary like: {'Features': [[values for features], [ ... ], ... , [ ... ]], 'Enzyme': [0, 1, 1, ..., 0, 1]} ###



###################################################################################################


